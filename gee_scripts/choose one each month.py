# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15mHmpKcKzPc7sH3JBuxt0SS3y3j-Vr7u
"""

# Install required packages (Colab; safe to re-run)
!pip install rasterio matplotlib tqdm

# Mount Google Drive when running on Colab
from google.colab import drive
drive.mount('/content/drive')

import os
import re
import numpy as np
import rasterio
from PIL import Image
from tqdm import tqdm
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
import gc

# Configuration: input/output roots and parallel/batch settings
input_root = "/content/drive/MyDrive/lake100_orignal"
output_root = "/content/drive/MyDrive/image"
os.makedirs(output_root, exist_ok=True)

batch_size = 200
max_workers = 2

# Image scoring heuristic:
# - reject frames with NaN/invalid shapes or very dark/low-contrast centres
# - penalise bright grey (cloud-like) and saturated white pixels
# - lower score is better; return (-score, reason)
def image_score(img):
    # Basic dimensional checks (expects at least 3 bands in CHW order)
    if img.shape[0] < 3 or img.shape[1] == 0 or img.shape[2] == 0:
        return -1, "❌ Insufficient channels or zero dimension"

    # Reject frames with NaN values
    if np.isnan(img).any():
        return -1, "❌ Image contains NaN"

    # Split channels and compute brightness
    r = img[0].astype(np.float32)
    g = img[1].astype(np.float32)
    b = img[2].astype(np.float32)
    brightness = (r + g + b) / 3
    h, w = brightness.shape

    # Central window statistics for basic quality control
    ch, cw = h // 4, w // 4
    center_r = r[ch:3 * ch, cw:3 * cw]
    center_g = g[ch:3 * ch, cw:3 * cw]
    center_b = b[ch:3 * ch, cw:3 * cw]
    center_brightness = (center_r + center_g + center_b) / 3

    center_mean = np.mean(center_brightness)
    center_std = np.std(center_brightness)

    # Cloud proxy: bright and near-grey pixels
    grayish = (np.abs(r - g) < 25) & (np.abs(r - b) < 25) & (np.abs(g - b) < 25)
    cloud_mask = (brightness > 220) & grayish
    cloud_ratio = np.sum(cloud_mask) / brightness.size

    # Proportions of saturated white and near-black pixels
    white_ratio = np.sum(brightness > 245) / brightness.size
    black_ratio = np.sum(brightness < 10) / brightness.size

    # Hard filters for centre quality and overall exposure
    if center_mean < 30:
        return -1, "Center brightness too low"
    if center_std < 5:
        return -1, "Center region contrast too low"
    if black_ratio > 0.2:
        return -1, "Too many black pixels"
    if np.max(brightness) < 50:
        return -1, "Overall brightness too low"

    # Aggregate score: clouds weighted more than specular whites
    score = cloud_ratio + 0.5 * white_ratio
    return -score, "Qualified"

# Evaluate all .tif files in a folder and export the best candidate as PNG
def process_folder(folder):
    try:
        tif_files = [f for f in os.listdir(folder) if f.lower().endswith(".tif")]
        if not tif_files:
            return f"No images: {folder}"

        best_score = float("-inf")
        best_img = None
        best_reason = ""

        for tif_name in tif_files:
            tif_path = os.path.join(folder, tif_name)
            with rasterio.open(tif_path) as src:
                img = src.read()
                if img.shape[0] < 3 or img.shape[1] == 0 or img.shape[2] == 0:
                    continue

                score, reason = image_score(img)
                if score > best_score:
                    best_score = score
                    best_img = img
                    best_reason = reason

        if best_img is None or best_score == -1:
            return f"No valid image: {folder} (Reason: {best_reason})"

        # Convert first three bands to uint8 RGB and save
        rgb = best_img[:3].astype(np.uint8)
        rgb = np.transpose(rgb, (1, 2, 0))
        img_pil = Image.fromarray(rgb)

        # Expect folder names like "<lake>-<YY>-<MM>"; parse to construct filename
        folder_name = os.path.basename(folder)
        match = re.match(r"(.*)-(\d{2})-(\d{2})", folder_name)
        if match:
            lake, year, month = match.groups()
        else:
            return f"Unable to parse: {folder_name}"

        filename = f"{lake}_{year}_{month}_img.png"
        out_path = os.path.join(output_root, filename)
        img_pil.save(out_path)

        del best_img, rgb, img_pil
        gc.collect()
        return f"Saved: {filename} (Score: {best_score:.3f})"

    except Exception as e:
        return f"Error: {folder}\n{e}"

# Batch execution over subfolders of input_root using a thread pool
total = len(all_folders)
print(f"Total to process {total} folders, {batch_size} per batch")

start_all = time.time()

for i in range(0, total, batch_size):
    batch = all_folders[i:i + batch_size]
    print(f"\n🚀 Starting batch {i//batch_size + 1}, total {len(batch)}")

    start_batch = time.time()

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = {executor.submit(process_folder, folder): folder for folder in batch}
        for future in tqdm(as_completed(futures), total=len(futures), desc="📷 Processing"):
            result = future.result()
            print(result)
            with open("image_selection_log.txt", "a") as log:
                log.write(result + "\n")

    print(f"Current batch time: {(time.time() - start_batch):.2f} seconds")

print(f"\nAll processing completed, total time: {(time.time() - start_all)/60:.2f} minutes")
