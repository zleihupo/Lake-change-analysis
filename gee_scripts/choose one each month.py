# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15mHmpKcKzPc7sH3JBuxt0SS3y3j-Vr7u
"""

# 安装依赖（仅首次运行需要）
!pip install rasterio matplotlib tqdm

# 挂载 Google Drive（如果在 Colab 上运行）
from google.colab import drive
drive.mount('/content/drive')

import os
import re
import numpy as np
import rasterio
from PIL import Image
from tqdm import tqdm
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
import gc

# ========== 参数设置 ==========
input_root = "/content/drive/MyDrive/lake100_orignal"
output_root = "/content/drive/MyDrive/image"
os.makedirs(output_root, exist_ok=True)

batch_size = 200
max_workers = 2

# ========== 图像评分函数（增强版） ==========
# 最终严格版 image_score 函数


def image_score(img):
    # Step 0: 检查通道和尺寸
    if img.shape[0] < 3 or img.shape[1] == 0 or img.shape[2] == 0:
        return -1, "❌ 图像通道不足或尺寸为0"

    # Step 1: 检查是否含 NaN（可能来自损坏图像）
    if np.isnan(img).any():
        return -1, "❌ 图像包含 NaN"

    # Step 2: 预处理
    r = img[0].astype(np.float32)
    g = img[1].astype(np.float32)
    b = img[2].astype(np.float32)
    brightness = (r + g + b) / 3
    h, w = brightness.shape

    # Step 3: 中心区域检测
    ch, cw = h // 4, w // 4
    center_r = r[ch:3 * ch, cw:3 * cw]
    center_g = g[ch:3 * ch, cw:3 * cw]
    center_b = b[ch:3 * ch, cw:3 * cw]
    center_brightness = (center_r + center_g + center_b) / 3

    center_mean = np.mean(center_brightness)
    center_std = np.std(center_brightness)


    # Step 5: 云检测（灰白区域）
    grayish = (np.abs(r - g) < 25) & (np.abs(r - b) < 25) & (np.abs(g - b) < 25)
    cloud_mask = (brightness > 220) & grayish
    cloud_ratio = np.sum(cloud_mask) / brightness.size

    # Step 6: 白像素比例（强反射区域）
    white_ratio = np.sum(brightness > 245) / brightness.size

    # Step 7: 黑像素比例（缺失图）
    black_ratio = np.sum(brightness < 10) / brightness.size

    # Step 8: 图像完整性过滤
    if center_mean < 30:
        return -1, "中心亮度太低"
    if center_std < 5:
        return -1, "中心区域对比度太低"
    if black_ratio > 0.2:
        return -1, "黑像素过多"
    if np.max(brightness) < 50:
        return -1, "整体亮度不足"

    # Step 9: 综合评分（越小越优）
    score = cloud_ratio + 0.5 * white_ratio
    return -score, "✅ 合格"



# ========== 处理单个文件夹 ==========
def process_folder(folder):
    try:
        tif_files = [f for f in os.listdir(folder) if f.lower().endswith(".tif")]
        if not tif_files:
            return f"⚠️ 无图像: {folder}"

        best_score = float("-inf")
        best_img = None
        best_reason = ""

        for tif_name in tif_files:
            tif_path = os.path.join(folder, tif_name)
            with rasterio.open(tif_path) as src:
                img = src.read()
                if img.shape[0] < 3 or img.shape[1] == 0 or img.shape[2] == 0:
                    continue

                score, reason = image_score(img)
                if score > best_score:
                    best_score = score
                    best_img = img
                    best_reason = reason

        if best_img is None or best_score == -1:
            return f"⚠️ 无有效图像: {folder}（原因：{best_reason}）"

        rgb = best_img[:3].astype(np.uint8)
        rgb = np.transpose(rgb, (1, 2, 0))
        img_pil = Image.fromarray(rgb)

        folder_name = os.path.basename(folder)
        match = re.match(r"(.*)-(\d{2})-(\d{2})", folder_name)
        if match:
            lake, year, month = match.groups()
        else:
            return f"⚠️ 无法解析: {folder_name}"

        filename = f"{lake}_{year}_{month}_img.png"
        out_path = os.path.join(output_root, filename)
        img_pil.save(out_path)

        del best_img, rgb, img_pil
        gc.collect()
        return f"✅ 保存: {filename}（评分: {best_score:.3f}）"

    except Exception as e:
        return f"❌ 错误: {folder}\n{e}"

# ========== 分批执行 ==========
total = len(all_folders)
print(f"📂 共需处理 {total} 个文件夹，每批 {batch_size} 个")

start_all = time.time()

for i in range(0, total, batch_size):
    batch = all_folders[i:i + batch_size]
    print(f"\n🚀 开始第 {i//batch_size + 1} 批，共 {len(batch)} 个")

    start_batch = time.time()

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = {executor.submit(process_folder, folder): folder for folder in batch}
        for future in tqdm(as_completed(futures), total=len(futures), desc="📷 处理中"):
            result = future.result()
            print(result)
            with open("image_selection_log.txt", "a") as log:
                log.write(result + "\n")

    print(f"✅ 当前批次耗时：{(time.time() - start_batch):.2f} 秒")

print(f"\n🎉 全部处理完成，总耗时：{(time.time() - start_all)/60:.2f} 分钟")


