# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15mHmpKcKzPc7sH3JBuxt0SS3y3j-Vr7u
"""

# å®‰è£…ä¾èµ–ï¼ˆä»…é¦–æ¬¡è¿è¡Œéœ€è¦ï¼‰
!pip install rasterio matplotlib tqdm

# æŒ‚è½½ Google Driveï¼ˆå¦‚æœåœ¨ Colab ä¸Šè¿è¡Œï¼‰
from google.colab import drive
drive.mount('/content/drive')

import os
import re
import numpy as np
import rasterio
from PIL import Image
from tqdm import tqdm
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
import gc

# ========== å‚æ•°è®¾ç½® ==========
input_root = "/content/drive/MyDrive/lake100_orignal"
output_root = "/content/drive/MyDrive/image"
os.makedirs(output_root, exist_ok=True)

batch_size = 200
max_workers = 2

# ========== å›¾åƒè¯„åˆ†å‡½æ•°ï¼ˆå¢å¼ºç‰ˆï¼‰ ==========
# æœ€ç»ˆä¸¥æ ¼ç‰ˆ image_score å‡½æ•°


def image_score(img):
    # Step 0: æ£€æŸ¥é€šé“å’Œå°ºå¯¸
    if img.shape[0] < 3 or img.shape[1] == 0 or img.shape[2] == 0:
        return -1, "âŒ å›¾åƒé€šé“ä¸è¶³æˆ–å°ºå¯¸ä¸º0"

    # Step 1: æ£€æŸ¥æ˜¯å¦å« NaNï¼ˆå¯èƒ½æ¥è‡ªæŸåå›¾åƒï¼‰
    if np.isnan(img).any():
        return -1, "âŒ å›¾åƒåŒ…å« NaN"

    # Step 2: é¢„å¤„ç†
    r = img[0].astype(np.float32)
    g = img[1].astype(np.float32)
    b = img[2].astype(np.float32)
    brightness = (r + g + b) / 3
    h, w = brightness.shape

    # Step 3: ä¸­å¿ƒåŒºåŸŸæ£€æµ‹
    ch, cw = h // 4, w // 4
    center_r = r[ch:3 * ch, cw:3 * cw]
    center_g = g[ch:3 * ch, cw:3 * cw]
    center_b = b[ch:3 * ch, cw:3 * cw]
    center_brightness = (center_r + center_g + center_b) / 3

    center_mean = np.mean(center_brightness)
    center_std = np.std(center_brightness)


    # Step 5: äº‘æ£€æµ‹ï¼ˆç°ç™½åŒºåŸŸï¼‰
    grayish = (np.abs(r - g) < 25) & (np.abs(r - b) < 25) & (np.abs(g - b) < 25)
    cloud_mask = (brightness > 220) & grayish
    cloud_ratio = np.sum(cloud_mask) / brightness.size

    # Step 6: ç™½åƒç´ æ¯”ä¾‹ï¼ˆå¼ºåå°„åŒºåŸŸï¼‰
    white_ratio = np.sum(brightness > 245) / brightness.size

    # Step 7: é»‘åƒç´ æ¯”ä¾‹ï¼ˆç¼ºå¤±å›¾ï¼‰
    black_ratio = np.sum(brightness < 10) / brightness.size

    # Step 8: å›¾åƒå®Œæ•´æ€§è¿‡æ»¤
    if center_mean < 30:
        return -1, "ä¸­å¿ƒäº®åº¦å¤ªä½"
    if center_std < 5:
        return -1, "ä¸­å¿ƒåŒºåŸŸå¯¹æ¯”åº¦å¤ªä½"
    if black_ratio > 0.2:
        return -1, "é»‘åƒç´ è¿‡å¤š"
    if np.max(brightness) < 50:
        return -1, "æ•´ä½“äº®åº¦ä¸è¶³"

    # Step 9: ç»¼åˆè¯„åˆ†ï¼ˆè¶Šå°è¶Šä¼˜ï¼‰
    score = cloud_ratio + 0.5 * white_ratio
    return -score, "âœ… åˆæ ¼"



# ========== å¤„ç†å•ä¸ªæ–‡ä»¶å¤¹ ==========
def process_folder(folder):
    try:
        tif_files = [f for f in os.listdir(folder) if f.lower().endswith(".tif")]
        if not tif_files:
            return f"âš ï¸ æ— å›¾åƒ: {folder}"

        best_score = float("-inf")
        best_img = None
        best_reason = ""

        for tif_name in tif_files:
            tif_path = os.path.join(folder, tif_name)
            with rasterio.open(tif_path) as src:
                img = src.read()
                if img.shape[0] < 3 or img.shape[1] == 0 or img.shape[2] == 0:
                    continue

                score, reason = image_score(img)
                if score > best_score:
                    best_score = score
                    best_img = img
                    best_reason = reason

        if best_img is None or best_score == -1:
            return f"âš ï¸ æ— æœ‰æ•ˆå›¾åƒ: {folder}ï¼ˆåŸå› ï¼š{best_reason}ï¼‰"

        rgb = best_img[:3].astype(np.uint8)
        rgb = np.transpose(rgb, (1, 2, 0))
        img_pil = Image.fromarray(rgb)

        folder_name = os.path.basename(folder)
        match = re.match(r"(.*)-(\d{2})-(\d{2})", folder_name)
        if match:
            lake, year, month = match.groups()
        else:
            return f"âš ï¸ æ— æ³•è§£æ: {folder_name}"

        filename = f"{lake}_{year}_{month}_img.png"
        out_path = os.path.join(output_root, filename)
        img_pil.save(out_path)

        del best_img, rgb, img_pil
        gc.collect()
        return f"âœ… ä¿å­˜: {filename}ï¼ˆè¯„åˆ†: {best_score:.3f}ï¼‰"

    except Exception as e:
        return f"âŒ é”™è¯¯: {folder}\n{e}"

# ========== åˆ†æ‰¹æ‰§è¡Œ ==========
total = len(all_folders)
print(f"ğŸ“‚ å…±éœ€å¤„ç† {total} ä¸ªæ–‡ä»¶å¤¹ï¼Œæ¯æ‰¹ {batch_size} ä¸ª")

start_all = time.time()

for i in range(0, total, batch_size):
    batch = all_folders[i:i + batch_size]
    print(f"\nğŸš€ å¼€å§‹ç¬¬ {i//batch_size + 1} æ‰¹ï¼Œå…± {len(batch)} ä¸ª")

    start_batch = time.time()

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = {executor.submit(process_folder, folder): folder for folder in batch}
        for future in tqdm(as_completed(futures), total=len(futures), desc="ğŸ“· å¤„ç†ä¸­"):
            result = future.result()
            print(result)
            with open("image_selection_log.txt", "a") as log:
                log.write(result + "\n")

    print(f"âœ… å½“å‰æ‰¹æ¬¡è€—æ—¶ï¼š{(time.time() - start_batch):.2f} ç§’")

print(f"\nğŸ‰ å…¨éƒ¨å¤„ç†å®Œæˆï¼Œæ€»è€—æ—¶ï¼š{(time.time() - start_all)/60:.2f} åˆ†é’Ÿ")


