# -*- coding: utf-8 -*-
"""MAP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iIEIAnBnAPv7qmFiHklw079GHKVMkYDo
"""

!pip -q install folium branca statsmodels

import pandas as pd
import numpy as np
import re
import statsmodels.api as sm
import folium
import branca.colormap as cm
import os
from google.colab import files

# ==== 1) 确保文件存在，否则上传 ====
for fname in ["100Lake_area_Temperature_2000-2025.csv", "100lake.csv"]:
    if not os.path.exists(f"/content/{fname}"):
        print(f"未找到 {fname}，请上传：")
        uploaded = files.upload()
        for k in uploaded.keys():
            print(f"已上传: {k}")

# ==== 2) 读取并清洗主数据 ====
df = pd.read_csv('/content/100Lake_area_Temperature_2000-2025.csv')

def clean_area(val):
    if pd.isna(val):
        return np.nan
    m = re.search(r"[-+]?\d*\.\d+|\d+", str(val))
    if m:
        try:
            return float(m.group(0).replace(',', ''))
        except:
            return np.nan
    return np.nan

df['area_m2'] = df['area_m2'].apply(clean_area)
df = df[df['area_m2'] > 0].copy()

# 仅保留夏季月份
def is_summer(row):
    hemi = str(row['hemisphere']).lower()
    if hemi.startswith('north'):
        return row['month'] in [6,7,8]
    else:
        return row['month'] in [12,1,2]

df['is_summer'] = df.apply(is_summer, axis=1)
df = df[df['is_summer']].copy()

# ==== 3) 每湖泊趋势计算 ====
def trend_per_decade(series_year, series_value):
    d = pd.DataFrame({'year': series_year, 'y': series_value}).dropna()
    if d['year'].nunique() < 4:
        return np.nan
    X = sm.add_constant(d['year'])
    model = sm.OLS(d['y'], X).fit()
    return float(model.params['year'] * 10.0)

vars_climate = ['temp_C','precip_mm','pet_mm','snow_cover_pct','snow_depth_cm']
climate_trends = []

for lake, g in df.groupby('lake'):
    g = g.sort_values('year')
    baseline = g[(g['year']>=2000)&(g['year']<=2002)]['area_m2'].mean()
    if pd.notna(baseline) and baseline>0:
        g['area_index'] = g['area_m2']/baseline
        area_slope = trend_per_decade(g['year'], g['area_index'])
    else:
        area_slope = np.nan
    rec = {'lake': lake, 'area_trend_per_decade': area_slope}
    for var in vars_climate:
        rec[f'{var}_trend_per_decade'] = trend_per_decade(g['year'], g[var])
    climate_trends.append(rec)

trends_df = pd.DataFrame(climate_trends)

# ==== 4) 湖泊坐标 ====
coords = pd.read_csv('/content/100lake.csv', encoding='latin1')

def rect_center(rect_str):
    nums = re.findall(r"[-+]?\d*\.\d+|\d+", str(rect_str))
    if len(nums) >= 4:
        lon1, lat1, lon2, lat2 = map(float, nums[:4])
        return (lat1+lat2)/2, (lon1+lon2)/2
    return np.nan, np.nan

coords['lat'], coords['lon'] = zip(*coords['rectangle'].map(rect_center))
coords_clean = coords[['lake_name','lat','lon']].dropna()

map_df = coords_clean.merge(trends_df, left_on='lake_name', right_on='lake', how='left')

# ==== 5) folium 交互地图 ====
def clip(v, lo, hi):
    try:
        return max(lo, min(hi, float(v)))
    except:
        return 0.0

area_vals = map_df['area_trend_per_decade'].dropna()
vmin = -0.6 if area_vals.empty else float(np.percentile(area_vals, 5))
vmax = 0.6 if area_vals.empty else float(np.percentile(area_vals, 95))
if vmin == vmax:
    vmin, vmax = -0.1, 0.1

colormap = cm.LinearColormap(colors=['red','white','blue'], vmin=vmin, vmax=vmax)
colormap.caption = 'Lake summer area trend (per decade, index units)'

m = folium.Map(location=[20, 0], zoom_start=2, tiles='CartoDB positron')

for _, r in map_df.iterrows():
    lat, lon = r['lat'], r['lon']
    if pd.isna(lat) or pd.isna(lon):
        continue
    a = r['area_trend_per_decade']
    color = '#888888' if pd.isna(a) else colormap(clip(a, vmin, vmax))
    def fmt(x, suf=''):
        return 'NA' if (pd.isna(x) or x is None) else f"{x:.3f}{suf}"
    popup_html = f"""
    <div style="font-size:13px;">
    <b>{r['lake_name']}</b><br>
    <table style="border-collapse:collapse;">
      <tr><td>Area trend</td><td><b>{fmt(a)}</b> / decade</td></tr>
      <tr><td>Temp trend</td><td>{fmt(r['temp_C_trend_per_decade'], ' °C/dec')}</td></tr>
      <tr><td>Precip trend</td><td>{fmt(r['precip_mm_trend_per_decade'], ' mm/dec')}</td></tr>
      <tr><td>PET trend</td><td>{fmt(r['pet_mm_trend_per_decade'], ' mm/dec')}</td></tr>
      <tr><td>Snow cover trend</td><td>{fmt(r['snow_cover_pct_trend_per_decade'], ' %/dec')}</td></tr>
      <tr><td>Snow depth trend</td><td>{fmt(r['snow_depth_cm_trend_per_decade'], ' cm/dec')}</td></tr>
    </table>
    </div>
    """
    folium.CircleMarker(
        location=[lat, lon],
        radius=5,
        color=color,
        fill=True,
        fill_color=color,
        fill_opacity=0.85,
        opacity=0.9,
        popup=folium.Popup(popup_html, max_width=300)
    ).add_to(m)

colormap.add_to(m)

title_html = '''
<div style="position: fixed;
     top: 10px; left: 50px; width: 420px; z-index:9999;
     background-color: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 6px;
     box-shadow: 0 2px 6px rgba(0,0,0,0.2); font-size:14px;">
<b>Lake Summer Area Trend & Climate Factor Trends (2000–2025)</b><br>
Color = Area trend per decade (blue ↑, red ↓). Click points for detailed climate trends.
</div>
'''
m.get_root().html.add_child(folium.Element(title_html))

# ==== 6) 保存地图 ====
out_path = '/content/lake_area_trend_with_climate.html'
m.save(out_path)
print(f"✅ 地图已保存：{out_path}")
print("在 Colab 左侧文件面板中右键下载，或运行下面命令下载：")
print(f"from google.colab import files; files.download('{out_path}')")

from google.colab import files
files.download('/content/lake_area_trend_with_climate.html')

# =========================
# 安装依赖（Colab）
# =========================
!pip -q install statsmodels folium branca

# =========================
# 导入与基础设置
# =========================
import os, re, numpy as np, pandas as pd
import statsmodels.api as sm
import folium
import branca.colormap as cm
from google.colab import files

# =========================
# 若文件未找到，则触发上传
# =========================
needed = ["100Lake_area_Temperature_2000-2025.csv", "100lake.csv"]
for fname in needed:
    if not os.path.exists(f"/content/{fname}"):
        print(f"未找到 {fname}，请上传该文件：")
        uploaded = files.upload()
        for k in uploaded.keys():
            print(f"已上传: {k}")
    else:
        print(f"已找到：/content/{fname}")

# =========================
# Helper 函数
# =========================
def clean_area(val):
    """从字符串中提取数值，转为 float。其他返回 NaN。"""
    if pd.isna(val):
        return np.nan
    m = re.search(r"[-+]?\d*\.\d+|\d+", str(val))
    if m:
        try:
            return float(m.group(0).replace(',', ''))
        except:
            return np.nan
    return np.nan

def is_summer(row):
    """按半球判断夏季月份：北半球6-8，南半球12-2。"""
    hemi = str(row['hemisphere']).lower()
    if hemi.startswith('north'):
        return row['month'] in [6,7,8]
    else:
        return row['month'] in [12,1,2]

def slope_per_decade(years, values):
    """线性回归斜率 ×10，得到每十年的变化。"""
    d = pd.DataFrame({'year': years, 'y': values}).dropna()
    if d['year'].nunique() < 4:
        return np.nan
    X = sm.add_constant(d['year'])
    m = sm.OLS(d['y'], X).fit()
    return float(m.params['year'] * 10.0)

def rect_center(rect_str):
    """解析 ee.Geometry.Rectangle([lon1,lat1,lon2,lat2]) -> (lat_center, lon_center)"""
    nums = re.findall(r"[-+]?\d*\.\d+|\d+", str(rect_str))
    if len(nums) >= 4:
        lon1, lat1, lon2, lat2 = map(float, nums[:4])
        return (lat1+lat2)/2, (lon1+lon2)/2
    return np.nan, np.nan

def read_100lake_csv(path="/content/100lake.csv"):
    """尝试多种编码读取 100lake.csv"""
    for enc in ("utf-8", "utf-8-sig", "gbk", "latin1", "ISO-8859-1"):
        try:
            return pd.read_csv(path, encoding=enc)
        except Exception:
            pass
    # 最后尝试不指定编码
    return pd.read_csv(path)

# =========================
# 1) 读取并清洗主数据（仅夏季）
# =========================
df = pd.read_csv('/content/100Lake_area_Temperature_2000-2025.csv')

# 基础列校验
required_main_cols = {'lake','region','hemisphere','year','month','area_m2',
                      'temp_C','precip_mm','pet_mm','snow_cover_pct','snow_depth_cm'}
missing = required_main_cols - set(df.columns)
if missing:
    raise ValueError(f"主数据缺少必要列: {missing}")

df['area_m2'] = df['area_m2'].apply(clean_area)
df = df[df['area_m2'] > 0].copy()

df['is_summer'] = df.apply(is_summer, axis=1)
df = df[df['is_summer']].copy()

# =========================
# 2) 基于 2000-2002 的湖泊基线 -> area_index
#    若该湖2000-2002缺失，则回退为该湖前3条记录均值
# =========================
baseline = (
    df[(df['year']>=2000)&(df['year']<=2002)]
    .groupby('lake')['area_m2'].mean()
    .rename('baseline_area_m2')
)

first3 = (
    df.sort_values(['lake','year','month'])
      .groupby('lake').head(3)
      .groupby('lake')['area_m2'].mean()
      .rename('fallback')
)

base = pd.concat([baseline, first3], axis=1)
base['baseline_area_m2'] = base['baseline_area_m2'].fillna(base['fallback'])
base = base[['baseline_area_m2']].dropna()

df = df.merge(base, left_on='lake', right_index=True, how='inner')
df['area_index'] = df['area_m2'] / df['baseline_area_m2']

# =========================
# 3) 聚合到 region-year 层，计算温度/面积指数趋势（每十年）
# =========================
reg_year = (df.groupby(['region','year'])
            .agg(mean_temp=('temp_C','mean'),
                 mean_area_index=('area_index','mean'))
            .reset_index())

regions = sorted(reg_year['region'].unique().tolist())
trend_rows = []
for reg in regions:
    d = reg_year[reg_year['region']==reg]
    t_slope = slope_per_decade(d['year'], d['mean_temp'])
    a_slope = slope_per_decade(d['year'], d['mean_area_index'])
    trend_rows.append({'region': reg,
                       'temp_trend_C_per_decade': t_slope,
                       'area_index_trend_per_decade': a_slope})
trend_tbl = pd.DataFrame(trend_rows)

# =========================
# 4) 使用 100lake.csv 的矩形坐标求湖泊中心 -> 求每区域质心
# =========================
coords = read_100lake_csv('/content/100lake.csv')
if 'rectangle' not in coords.columns or 'lake_name' not in coords.columns:
    raise ValueError("100lake.csv 需要包含 'rectangle' 和 'lake_name' 列。")

coords['lat'], coords['lon'] = zip(*coords['rectangle'].map(rect_center))
coords = coords[['lake_name','lat','lon']].dropna()

# lake_name -> region 映射来自主数据 df
lake_to_region = df[['lake','region']].drop_duplicates().rename(columns={'lake':'lake_name'})
coords_reg = coords.merge(lake_to_region, on='lake_name', how='left').dropna(subset=['region'])

# 区域质心 = 该区域内各湖中心点的均值
reg_centroids = (coords_reg.groupby('region')
                 .agg(lat=('lat','mean'), lon=('lon','mean'), n_lakes=('lake_name','nunique'))
                 .reset_index())

# 合并趋势与质心
reg_map = reg_centroids.merge(trend_tbl, on='region', how='left')

# =========================
# 5) 使用 folium 生成交互式区域趋势地图
#    - 图层1：温度趋势（蓝→白→红）
#    - 图层2：面积指数趋势（红→白→蓝）
# =========================
# 温度趋势配色范围：5%-95% 分位数增强对比（缺失则默认）
temp_vals = reg_map['temp_trend_C_per_decade'].dropna()
tmin = float(np.nanpercentile(temp_vals, 5)) if not temp_vals.empty else -0.2
tmax = float(np.nanpercentile(temp_vals, 95)) if not temp_vals.empty else 0.8
if tmin == tmax:
    tmin, tmax = -0.1, 0.1
cmap_temp = cm.LinearColormap(colors=['blue','white','red'], vmin=tmin, vmax=tmax)
cmap_temp.caption = 'Summer Temperature Trend (°C per decade)'

# 面积趋势配色范围：5%-95% 分位数（缺失则默认）
area_vals = reg_map['area_index_trend_per_decade'].dropna()
amin = float(np.nanpercentile(area_vals, 5)) if not area_vals.empty else -0.4
amax = float(np.nanpercentile(area_vals, 95)) if not area_vals.empty else 0.4
if amin == amax:
    amin, amax = -0.1, 0.1
cmap_area = cm.LinearColormap(colors=['red','white','blue'], vmin=amin, vmax=amax)
cmap_area.caption = 'Summer Lake Area Index Trend (per decade)'

m = folium.Map(location=[25, 10], zoom_start=2, tiles='CartoDB positron')

fg_temp = folium.FeatureGroup(name='Temperature Trend (°C/dec)', show=True)
fg_area = folium.FeatureGroup(name='Area Index Trend (/dec)', show=True)

for _, r in reg_map.iterrows():
    lat, lon = r['lat'], r['lon']
    if pd.isna(lat) or pd.isna(lon):
        continue
    # 温度图层
    t = r['temp_trend_C_per_decade']
    color_t = '#888888' if pd.isna(t) else cmap_temp(t)
    popup_t = folium.Popup(
        f"<b>{r['region']}</b><br>"
        f"Temp trend: {t if pd.notna(t) else 'NA':.3f} °C/dec<br>"
        f"Area trend: {r['area_index_trend_per_decade'] if pd.notna(r['area_index_trend_per_decade']) else float('nan'):.3f} /dec<br>"
        f"N lakes used: {int(r['n_lakes'])}",
        max_width=300
    )
    folium.CircleMarker(
        location=[lat,lon], radius=8, color=color_t,
        fill=True, fill_color=color_t, fill_opacity=0.85, popup=popup_t
    ).add_to(fg_temp)
    # 面积图层
    a = r['area_index_trend_per_decade']
    color_a = '#888888' if pd.isna(a) else cmap_area(a)
    popup_a = folium.Popup(
        f"<b>{r['region']}</b><br>"
        f"Area trend: {a if pd.notna(a) else 'NA':.3f} /dec<br>"
        f"Temp trend: {t if pd.notna(t) else 'NA':.3f} °C/dec<br>"
        f"N lakes used: {int(r['n_lakes'])}",
        max_width=300
    )
    folium.CircleMarker(
        location=[lat,lon], radius=8, color=color_a,
        fill=True, fill_color=color_a, fill_opacity=0.85, popup=popup_a
    ).add_to(fg_area)

fg_temp.add_to(m)
fg_area.add_to(m)
cmap_temp.add_to(m)
cmap_area.add_to(m)
folium.LayerControl(collapsed=False).add_to(m)

title_html = '''
<div style="position: fixed;
     top: 10px; left: 50px; width: 520px; z-index:9999;
     background-color: rgba(255,255,255,0.95); padding: 8px 12px; border-radius: 6px;
     box-shadow: 0 2px 6px rgba(0,0,0,0.2); font-size:14px;">
<b>Region-level Map: Summer Temperature & Lake Area Trends (2000–2025)</b><br>
Toggle layers to view temperature trend (blue→red) or area trend (red→blue). Click markers for details.
</div>
'''
m.get_root().html.add_child(folium.Element(title_html))

# =========================
# 保存并提示下载
# =========================
out_path = '/content/region_trends_map.html'
m.save(out_path)
print(f"✅ 地图已保存：{out_path}")
print("可直接在左侧 /content 下载，或运行以下命令下载：")
print(f"from google.colab import files; files.download('{out_path}')")

from google.colab import files
files.download('/content/region_trends_map.html')

# =========================
# 安装依赖（Colab）
# =========================
!pip -q install statsmodels folium

# =========================
# 导入
# =========================
import os, re
import numpy as np
import pandas as pd
import statsmodels.api as sm
import folium
from folium.plugins import HeatMap
from google.colab import files

# =========================
# 若文件未找到则触发上传
# =========================
def ensure_file(fname):
    path = f"/content/{fname}"
    if not os.path.exists(path):
        print(f"未找到 {fname}，请上传该文件：")
        uploaded = files.upload()
        for k in uploaded.keys():
            print(f"已上传: {k}")
    else:
        print(f"已找到：{path}")

ensure_file("100Lake_area_Temperature_2000-2025.csv")
ensure_file("100lake.csv")

# =========================
# Helpers
# =========================
def clean_area(val):
    if pd.isna(val):
        return np.nan
    m = re.search(r"[-+]?\d*\.\d+|\d+", str(val))
    if m:
        try:
            return float(m.group(0).replace(',', ''))
        except:
            return np.nan
    return np.nan

def is_summer(row):
    hemi = str(row['hemisphere']).lower()
    if hemi.startswith('north'):
        return row['month'] in [6,7,8]
    else:
        return row['month'] in [12,1,2]

def trend_per_decade(years, values):
    d = pd.DataFrame({'year': years, 'y': values}).dropna()
    if d['year'].nunique() < 4:
        return np.nan
    X = sm.add_constant(d['year'])
    m = sm.OLS(d['y'], X).fit()
    return float(m.params['year'] * 10.0)

def rect_center(rect_str):
    nums = re.findall(r"[-+]?\d*\.\d+|\d+", str(rect_str))
    if len(nums) >= 4:
        lon1, lat1, lon2, lat2 = map(float, nums[:4])
        return (lat1+lat2)/2, (lon1+lon2)/2
    return np.nan, np.nan

def read_100lake_csv(path="/content/100lake.csv"):
    for enc in ("utf-8", "utf-8-sig", "gbk", "latin1", "ISO-8859-1"):
        try:
            return pd.read_csv(path, encoding=enc)
        except Exception:
            pass
    return pd.read_csv(path)

# =========================
# 1) 读取数据（仅夏季）
# =========================
df = pd.read_csv('/content/100Lake_area_Temperature_2000-2025.csv')

# 必要列检查
need_cols = {'lake','hemisphere','year','month','area_m2','temp_C'}
miss = need_cols - set(df.columns)
if miss:
    raise ValueError(f"主数据缺少必要列: {miss}")

df['area_m2'] = df['area_m2'].apply(clean_area)
df = df[df['area_m2'] > 0].copy()
df['is_summer'] = df.apply(is_summer, axis=1)
df = df[df['is_summer']].copy()

coords = read_100lake_csv('/content/100lake.csv')
if 'rectangle' not in coords.columns or 'lake_name' not in coords.columns:
    raise ValueError("100lake.csv 需要包含 'rectangle' 和 'lake_name' 列。")

coords['lat'], coords['lon'] = zip(*coords['rectangle'].map(rect_center))
coords = coords[['lake_name','lat','lon']].dropna()

# =========================
# 2) 逐湖泊计算夏季趋势
# =========================
records = []
for lake, g in df.groupby('lake'):
    g = g.sort_values('year')
    # 面积指数基线（2000-2002）
    baseline = g[(g['year']>=2000)&(g['year']<=2002)]['area_m2'].mean()
    area_trend = np.nan
    if pd.notna(baseline) and baseline > 0:
        g['area_index'] = g['area_m2'] / baseline
        area_trend = trend_per_decade(g['year'], g['area_index'])
    # 温度趋势
    temp_trend = trend_per_decade(g['year'], g['temp_C'])
    records.append({'lake': lake, 'area_trend': area_trend, 'temp_trend': temp_trend})

trends = pd.DataFrame(records)

# 合并坐标
points = coords.merge(trends, left_on='lake_name', right_on='lake', how='left').dropna(subset=['lat','lon'])

# =========================
# 3) 热力层准备
# =========================
def norm_weights(series):
    s = series.replace([np.inf, -np.inf], np.nan).dropna()
    if s.empty:
        return pd.Series(np.zeros(len(series)), index=series.index, dtype=float)
    lo, hi = np.percentile(np.abs(s), [5, 95])
    hi = max(hi, lo + 1e-9)
    w = np.clip(np.abs(series), lo, hi)
    return ((w - lo) / (hi - lo)).fillna(0.0)

area_pos = points[(points['area_trend'].notna()) & (points['area_trend']>0)].copy()
area_neg = points[(points['area_trend'].notna()) & (points['area_trend']<0)].copy()
temp_pos = points[(points['temp_trend'].notna()) & (points['temp_trend']>0)].copy()
temp_neg = points[(points['temp_trend'].notna()) & (points['temp_trend']<0)].copy()

area_pos['w'] = norm_weights(area_pos['area_trend'])
area_neg['w'] = norm_weights(area_neg['area_trend'])
temp_pos['w'] = norm_weights(temp_pos['temp_trend'])
temp_neg['w'] = norm_weights(temp_neg['temp_trend'])

# =========================
# 4) 构建交互式热力图
# =========================
m = folium.Map(location=[20, 0], zoom_start=2, tiles='CartoDB positron')

grad_blue   = {0.2:'#b3d9ff', 0.5:'#66b3ff', 0.8:'#1a8cff', 1.0:'#0059b3'}  # Area ↑
grad_red    = {0.2:'#ffb3b3', 0.5:'#ff6666', 0.8:'#ff1a1a', 1.0:'#b30000'}  # Area ↓
grad_orange = {0.2:'#ffd9b3', 0.5:'#ffb366', 0.8:'#ff8c1a', 1.0:'#b35a00'}  # Temp ↑
grad_cyan   = {0.2:'#b3ffff', 0.5:'#66ffff', 0.8:'#1affff', 1.0:'#00b3b3'}  # Temp ↓

fg_area_pos = folium.FeatureGroup(name='Area Trend ↑ (per decade)', show=True)
fg_area_neg = folium.FeatureGroup(name='Area Trend ↓ (per decade)', show=True)
fg_temp_pos = folium.FeatureGroup(name='Temp Trend ↑ (°C per decade)', show=False)
fg_temp_neg = folium.FeatureGroup(name='Temp Trend ↓ (°C per decade)', show=False)

if not area_pos.empty:
    HeatMap(area_pos[['lat','lon','w']].values.tolist(),
            min_opacity=0.2, max_zoom=6, radius=18, blur=22, gradient=grad_blue).add_to(fg_area_pos)
if not area_neg.empty:
    HeatMap(area_neg[['lat','lon','w']].values.tolist(),
            min_opacity=0.2, max_zoom=6, radius=18, blur=22, gradient=grad_red).add_to(fg_area_neg)
if not temp_pos.empty:
    HeatMap(temp_pos[['lat','lon','w']].values.tolist(),
            min_opacity=0.2, max_zoom=6, radius=18, blur=22, gradient=grad_orange).add_to(fg_temp_pos)
if not temp_neg.empty:
    HeatMap(temp_neg[['lat','lon','w']].values.tolist(),
            min_opacity=0.2, max_zoom=6, radius=18, blur=22, gradient=grad_cyan).add_to(fg_temp_neg)

fg_area_pos.add_to(m)
fg_area_neg.add_to(m)
fg_temp_pos.add_to(m)
fg_temp_neg.add_to(m)

# 可选点位图层
fg_points = folium.FeatureGroup(name='Lake Points', show=False)
for _, r in points.iterrows():
    popup = folium.Popup(
        f"<b>{r['lake_name']}</b><br>"
        f"Area trend: {r['area_trend'] if pd.notna(r['area_trend']) else 'NA'} /dec<br>"
        f"Temp trend: {r['temp_trend'] if pd.notna(r['temp_trend']) else 'NA'} °C/dec",
        max_width=260
    )
    folium.CircleMarker(
        location=[r['lat'], r['lon']],
        radius=3, color='#444', fill=True, fill_opacity=0.6, popup=popup
    ).add_to(fg_points)
fg_points.add_to(m)

folium.LayerControl(collapsed=False).add_to(m)

title_html = '''
<div style="position: fixed;
     top: 10px; left: 50px; width: 520px; z-index:9999;
     background-color: rgba(255,255,255,0.95); padding: 8px 12px; border-radius: 6px;
     box-shadow: 0 2px 6px rgba(0,0,0,0.2); font-size:14px;">
<b>Global Heatmap of Lake Trends (Summer, 2000–2025)</b><br>
Toggle layers: Area ↑(blue), Area ↓(red), Temp ↑(orange), Temp ↓(cyan). Intensity reflects magnitude.
</div>
'''
m.get_root().html.add_child(folium.Element(title_html))

# =========================
# 保存 & 下载提示
# =========================
out_path = '/content/global_heatmap_lakes_trends.html'
m.save(out_path)
print(f"✅ 热力图已保存：{out_path}")
print("你可以在左侧 /content 下载，或运行：")
print(f"from google.colab import files; files.download('{out_path}')")

from google.colab import files
files.download('/content/global_heatmap_lakes_trends.html')